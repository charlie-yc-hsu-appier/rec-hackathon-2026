lua_shared_dict prometheus_metrics 10M;
lua_package_path "/srv/nginx-lua-prometheus/?.lua";

# Reference: https://github.com/knyar/nginx-lua-prometheus
#            https://github.com/hnlq715/nginx-prometheus-metrics/blob/master/metrics.vhost
init_by_lua '
    prometheus = require("prometheus").init("prometheus_metrics")

    http_request_time = prometheus:histogram(
        "vendor_api_nginx_request_duration_seconds", "vendor api request latency observed from nginx",
        {"path", "status", "upstream_status", "site", "oid"},
        {0.01, 0.05, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 2.0}
    );
';

upstream server_backend {
    server 127.0.0.1:8080 max_fails=0 fail_timeout=0;
    least_conn;
    keepalive 64;
}

log_format vendor_api_access '$remote_addr - $remote_user [$time_local] '
                             '"$request" $status $upstream_status $body_bytes_sent '
                             '"$http_referer" "$http_user_agent" "$request_time" ';

server {
    server_name  _;
    listen       80;

    access_log /dev/stdout vendor_api_access;
    error_log  /var/log/nginx/error.log;

    location / {

        proxy_pass_header Server;

        proxy_set_header Host $http_host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Scheme $scheme;
        proxy_set_header X-Forwarded-Proto $scheme;

        proxy_connect_timeout 1s;
        proxy_read_timeout 3s;
        proxy_next_upstream off;
        proxy_next_upstream_tries 0;

        proxy_http_version 1.1;
        proxy_set_header Connection "";
        proxy_intercept_errors on;

        # Avoid accessing our prometheus statistics from the public internet.
        # Still return an empty response to not break prometheus scraper.
        location ~ ^/metrics {
            return 204;
        }

        location ~ ^/swagger {
            proxy_pass_header Server;
            proxy_pass http://server_backend;
            access_log    off;
            log_not_found off;
        }

        location = / {
            proxy_pass_header Server;
            proxy_pass http://server_backend;
            access_log    off;
            log_not_found off;
        }

        location = /healthz {
            proxy_pass_header Server;
            proxy_pass http://server_backend;
            access_log    off;
            log_not_found off;
        }

        location = /vendors {
            proxy_pass_header Server;
            proxy_pass http://server_backend;
            access_log    off;
            log_not_found off;
        }

        location ~ ^/r/.* {
            proxy_read_timeout 1s;
            proxy_pass http://server_backend;

            log_by_lua '
              local headers = ngx.req.get_headers()
              local sid = headers["x-rec-siteid"]
              if sid == nil then
                  sid = "unknown"
              end
              local oid = headers["x-rec-oid"]
              if oid == nil then
                  oid = "unknown"
              end
              http_request_time:observe(tonumber(ngx.var.request_time), {ngx.var.uri, ngx.var.status, ngx.var.upstream_status, sid, oid})
            ';
        }
    }
}


# Note: it's a endpoint for prometheus-server to fetch metrics data and only allow prometheus-server accessing.
# It would be a security hole if it's exposed in public networking.
server {
    listen 9200;
    location /metrics {
        content_by_lua 'prometheus:collect()';
        access_log    off;
        log_not_found off;
    }
}
